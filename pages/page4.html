<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>scratch 波形</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    /* ──────────────────────────────────────────
       修正ポイント：
       ・body に固定高さ(height:100vh)を指定せず、overflow: hidden を削除
       ・必要に応じて overflow: auto にする
       ・その結果、画面をスクロールできるようになる
    ────────────────────────────────────────── */
    body {
      background: #121212;
      color: #fff;
      font-family: 'Arial', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0;
      padding: 0;
      /* ↓ 削除しました
      height: 100vh;
      overflow: hidden;
      */
      /* もしスクロールバーを自動表示したい場合は以下を追加してください（不要なら省略可） */
      /* overflow-y: auto; */
    }
    h2 {
      margin-top: 20px;
      font-size: 2rem;
    }
    h3 {
      margin-top: 10px;
      font-size: 1rem;
      color: #ff8080;
    }
    #dropZone {
      width: 90%;
      max-width: 600px;
      height: 150px;
      border: 2px dashed #555;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #aaa;
      margin-top: 20px;
      cursor: pointer;
    }
    #dropZone.dragover {
      border-color: #ff4081;
      color: #ff4081;
      background: rgba(255, 64, 129, 0.1);
    }
    canvas {
      background: #1a1a1a;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
      margin-top: 20px;
    }
    textarea {
      width: 90%;
      max-width: 800px;
      height: 120px;
      margin-top: 20px;
      padding: 10px;
      border: none;
      border-radius: 8px;
      font-family: monospace;
      font-size: 1rem;
      background: #333;
      color: #fff;
      box-shadow: 0 0 8px rgba(255, 255, 255, 0.1);
      resize: none;
    }
    textarea:focus {
      outline: none;
      border: 1px solid #ff4081;
    }
    button {
      background-color: #6200ea;
      color: white;
      border: none;
      padding: 12px 24px;
      font-size: 1rem;
      font-weight: bold;
      border-radius: 30px;
      margin-top: 20px;
      cursor: pointer;
      transition: all 0.3s ease-in-out;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    }
    button:hover {
      background-color: #3700b3;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
      transform: translateY(-2px);
    }
    button:active {
      transform: translateY(0);
    }
    input[type="file"] {
      display: none;
    }
  </style>
</head>
<body>
  <h2>オーディオ/ビデオをアップロードしてSDF生成</h2>
  <h3>⚠️曲の再生中に他のタブに移動しないでください。</h3>

  <!-- ドラッグ＆ドロップエリア -->
  <div id="dropZone">ここに音声ファイルまたは動画ファイルをドラッグ＆ドロップ</div>
  <input type="file" id="audioFile" accept="audio/*,video/mp4" />

  <!-- キャンバス -->
  <canvas id="canvas"></canvas>

  <h3>SDF出力（編集可能）</h3>
  <textarea id="sdfTextArea" placeholder="[A]:000,001,002/...;"></textarea><br>
  <button id="exportSpriteBtn">sprite3を生成してDL</button>

  <script>
    // グローバル変数
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    let audioContext = null;
    let analyser = null;
    let dataArray = null;
    const numBars = 19;
    let collectedData = [];
    let animationId = null;
    let intervalId = null;
    let currentAudio = null;

    // キャンバスサイズをウィンドウ幅に合わせる
    function resizeCanvas() {
      canvas.width = window.innerWidth * 0.9;
      if (canvas.width > 1200) canvas.width = 1200;
      canvas.height = 400;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // ドラッグ＆ドロップのセットアップ
    const dropZone = document.getElementById("dropZone");
    dropZone.addEventListener("dragover", (e) => {
      e.preventDefault();
      dropZone.classList.add("dragover");
    });
    dropZone.addEventListener("dragleave", (e) => {
      e.preventDefault();
      dropZone.classList.remove("dragover");
    });
    dropZone.addEventListener("drop", (e) => {
      e.preventDefault();
      dropZone.classList.remove("dragover");
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        handleFile(files[0]);
      }
    });
    dropZone.addEventListener("click", () => {
      document.getElementById("audioFile").click();
    });

    // ファイル入力の変更イベント
    document.getElementById("audioFile").addEventListener("change", function () {
      const file = this.files[0];
      if (!file) return;
      handleFile(file);
    });

    // ファイルを処理して再生＆解析開始
    function handleFile(file) {
      // iOS Safari対策: AudioContext をユーザー操作の直後に作成して resume する
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      audioContext.resume().then(() => {
        const reader = new FileReader();
        reader.onload = function (e) {
          // 既存のAudio要素があれば停止して解放
          if (currentAudio) {
            currentAudio.pause();
            currentAudio.src = "";
            currentAudio.load();
            if (intervalId) clearInterval(intervalId);
            if (animationId) cancelAnimationFrame(animationId);
          }
          // Audio要素を生成
          const audio = new Audio(e.target.result);
          audio.setAttribute("playsinline", "true");
          audio.controls = true;
          audio.style.display = "none";
          document.body.appendChild(audio);
          currentAudio = audio;

          // 再生が終わったら解析を停止
          audio.addEventListener("ended", () => {
            if (intervalId) clearInterval(intervalId);
            if (animationId) cancelAnimationFrame(animationId);
            console.log("Audio ended, SDF collection stopped.");
          });

          // メディア要素ソースを作成して解析ノードに接続
          const source = audioContext.createMediaElementSource(audio);
          if (analyser) {
            analyser.disconnect();
          }
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 256;
          dataArray = new Uint8Array(analyser.frequencyBinCount);
          source.connect(analyser);
          analyser.connect(audioContext.destination);

          // SDF用データを初期化
          collectedData = [];

          // 50msごとに周波数データを取得してSDFテキストを更新
          intervalId = setInterval(() => {
            analyser.getByteFrequencyData(dataArray);
            const indices = Array.from({ length: numBars }, (_, i) =>
              Math.floor((i / numBars) * dataArray.length)
            );
            const frame = indices.map(i => String(dataArray[i]).padStart(3, "0"));
            collectedData.push(frame);
            updateSDFText();
          }, 50);

          // 描画ループ開始
          drawBars();

          // 再生開始
          const playPromise = audio.play();
          if (playPromise !== undefined) {
            playPromise.catch(error => {
              console.warn("Audio playback failed:", error);
            });
          }
        };
        reader.readAsDataURL(file);
      });
    }

    // バーを円形に描画する関数
    function drawBars() {
      animationId = requestAnimationFrame(drawBars);
      if (!analyser) return;
      analyser.getByteFrequencyData(dataArray);
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = 60;

      for (let i = 0; i < numBars; i++) {
        const angle = (i / numBars) * 2 * Math.PI;
        const index = Math.floor((i / numBars) * dataArray.length);
        const magnitude = dataArray[index];

        let length;
        if (magnitude <= 200) {
          length = (magnitude / 200) * 150;
        } else {
          length = 150 + Math.log10(1 + (magnitude - 200)) * 50;
        }

        const x = Math.cos(angle);
        const y = Math.sin(angle);

        ctx.lineWidth = 4;
        ctx.strokeStyle = `hsl(${i * 360 / numBars}, 100%, 50%)`;
        ctx.beginPath();
        ctx.moveTo(centerX + x * radius, centerY + y * radius);
        ctx.lineTo(centerX + x * (radius + length), centerY + y * (radius + length));
        ctx.stroke();
      }
    }

    // SDFテキストエリアを更新する関数
    function updateSDFText() {
      const letters = "ABCDEFGHIJKLMNOPQRS".split("");
      const lists = Array(numBars).fill().map(() => []);
      collectedData.forEach(frame => {
        for (let i = 0; i < numBars; i++) {
          lists[i].push(frame[i]);
        }
      });
      const sdf = lists.map((list, i) => `[${letters[i]}]:${list.join(",")}`).join("/");
      document.getElementById("sdfTextArea").value = sdf;
    }

    // sprite3生成のためのリストIDマップ
    const listIdMap = {
      A: "wrjicyhmuu[z,K{Ac*?7", B: "M~E+sSuFf0S^h!#u)uRO", C: ")J#bVgJXl+lus%%sY,N1",
      D: "GgA5?^h0@^_@0_72Zvsx", E: "qZKwKaO2Feywh43^p}Ls", F: "1Cz-*ryy;gF^5]ZAanfS",
      G: "?LQ0TxT|[cBZsm).|7qR", H: "+_.2N~a]F;E@D3Ri)*Hs", I: "zu!d#cLmu:p)rtvifjBA",
      J: "ct*M#U-GfnqrR6i-mA]D", K: "/rJ=`R,!v!=GoUmHkS^l", L: "N-n]=sxgVM:M;zuCe:5b",
      M: "Cq(Soa:;8`3N+F~ZCZ.d", N: "(1A6Qj7bJFq!tuAQ3Jqv", O: "Cb.YPA0Y/?q:@|W}^WT!",
      P: "]eRbhH$O@:G8-DAhSx%X", Q: "IygaQ}!z3FI_NN%Xs,RX", R: ".MR#i{o(C8cW61jupx2,",
      S: "DaQ(?yN~oH}].{;f(KTw"
    };

    // SDFテキストをパースしてオブジェクト化する関数
    function parseSDF(text) {
      const result = {};
      text.split("/").forEach(entry => {
        const match = entry.match(/\[([A-S])\]:(.+)/);
        if (match) {
          const key = match[1];
          const values = match[2].split(",").map(x => x.trim().padStart(3, "0"));
          result[key] = values;
        }
      });
      return result;
    }

    // sprite3ファイルを生成してダウンロードするボタンイベント
    document.getElementById("exportSpriteBtn").onclick = async () => {
      const sdfText = document.getElementById("sdfTextArea").value;
      const sdfData = parseSDF(sdfText);

      try {
        const response = await fetch("https://raw.githubusercontent.com/kikukick/kikukick_program_page/main/pages/.sprite3/ex.sprite3");
        if (!response.ok) {
          console.error("sprite3のテンプレート取得に失敗:", response.statusText);
          return;
        }
        const blob = await response.blob();
        const zip = await JSZip.loadAsync(blob);
        const spriteJson = JSON.parse(await zip.file("sprite.json").async("string"));

        for (const key in sdfData) {
          if (!listIdMap[key]) continue;
          const id = listIdMap[key];
          const listName = `[${key}]`;
          spriteJson.lists[id] = [listName, sdfData[key]];
        }

        zip.file("sprite.json", JSON.stringify(spriteJson, null, 2));
        const newBlob = await zip.generateAsync({ type: "blob" });

        const a = document.createElement("a");
        a.href = URL.createObjectURL(newBlob);
        a.download = "output_with_sdf.sprite3";
        a.click();
      } catch (err) {
        console.error("sprite3生成中にエラー:", err);
      }
    };
  </script>
</body>
</html>
